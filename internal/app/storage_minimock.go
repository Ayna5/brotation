package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/Ayna5/bannersRotation/internal/app.Storage -o ./storage_minimock.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements Storage
type StorageMock struct {
	t minimock.Tester

	funcAddBannerToSlot          func(ctx context.Context, bannerID uint64, slotID uint64) (err error)
	inspectFuncAddBannerToSlot   func(ctx context.Context, bannerID uint64, slotID uint64)
	afterAddBannerToSlotCounter  uint64
	beforeAddBannerToSlotCounter uint64
	AddBannerToSlotMock          mStorageMockAddBannerToSlot

	funcAddClickForBanner          func(ctx context.Context, bannerID uint64, slotID uint64, userGroupID uint64) (err error)
	inspectFuncAddClickForBanner   func(ctx context.Context, bannerID uint64, slotID uint64, userGroupID uint64)
	afterAddClickForBannerCounter  uint64
	beforeAddClickForBannerCounter uint64
	AddClickForBannerMock          mStorageMockAddClickForBanner

	funcBannersClickStatisticsFilterByDate          func(ctx context.Context, from int64, to int64) (ba1 []BannerStatistic, err error)
	inspectFuncBannersClickStatisticsFilterByDate   func(ctx context.Context, from int64, to int64)
	afterBannersClickStatisticsFilterByDateCounter  uint64
	beforeBannersClickStatisticsFilterByDateCounter uint64
	BannersClickStatisticsFilterByDateMock          mStorageMockBannersClickStatisticsFilterByDate

	funcBannersShowStatisticsFilterByDate          func(ctx context.Context, from int64, to int64) (ba1 []BannerStatistic, err error)
	inspectFuncBannersShowStatisticsFilterByDate   func(ctx context.Context, from int64, to int64)
	afterBannersShowStatisticsFilterByDateCounter  uint64
	beforeBannersShowStatisticsFilterByDateCounter uint64
	BannersShowStatisticsFilterByDateMock          mStorageMockBannersShowStatisticsFilterByDate

	funcGetBannerForSlot          func(ctx context.Context, slotID uint64, userGroupID uint64) (u1 uint64, err error)
	inspectFuncGetBannerForSlot   func(ctx context.Context, slotID uint64, userGroupID uint64)
	afterGetBannerForSlotCounter  uint64
	beforeGetBannerForSlotCounter uint64
	GetBannerForSlotMock          mStorageMockGetBannerForSlot

	funcRemoveBannerFromSlot          func(ctx context.Context, bannerID uint64, slotID uint64) (err error)
	inspectFuncRemoveBannerFromSlot   func(ctx context.Context, bannerID uint64, slotID uint64)
	afterRemoveBannerFromSlotCounter  uint64
	beforeRemoveBannerFromSlotCounter uint64
	RemoveBannerFromSlotMock          mStorageMockRemoveBannerFromSlot
}

// NewStorageMock returns a mock for Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddBannerToSlotMock = mStorageMockAddBannerToSlot{mock: m}
	m.AddBannerToSlotMock.callArgs = []*StorageMockAddBannerToSlotParams{}

	m.AddClickForBannerMock = mStorageMockAddClickForBanner{mock: m}
	m.AddClickForBannerMock.callArgs = []*StorageMockAddClickForBannerParams{}

	m.BannersClickStatisticsFilterByDateMock = mStorageMockBannersClickStatisticsFilterByDate{mock: m}
	m.BannersClickStatisticsFilterByDateMock.callArgs = []*StorageMockBannersClickStatisticsFilterByDateParams{}

	m.BannersShowStatisticsFilterByDateMock = mStorageMockBannersShowStatisticsFilterByDate{mock: m}
	m.BannersShowStatisticsFilterByDateMock.callArgs = []*StorageMockBannersShowStatisticsFilterByDateParams{}

	m.GetBannerForSlotMock = mStorageMockGetBannerForSlot{mock: m}
	m.GetBannerForSlotMock.callArgs = []*StorageMockGetBannerForSlotParams{}

	m.RemoveBannerFromSlotMock = mStorageMockRemoveBannerFromSlot{mock: m}
	m.RemoveBannerFromSlotMock.callArgs = []*StorageMockRemoveBannerFromSlotParams{}

	return m
}

type mStorageMockAddBannerToSlot struct {
	mock               *StorageMock
	defaultExpectation *StorageMockAddBannerToSlotExpectation
	expectations       []*StorageMockAddBannerToSlotExpectation

	callArgs []*StorageMockAddBannerToSlotParams
	mutex    sync.RWMutex
}

// StorageMockAddBannerToSlotExpectation specifies expectation struct of the Storage.AddBannerToSlot
type StorageMockAddBannerToSlotExpectation struct {
	mock    *StorageMock
	params  *StorageMockAddBannerToSlotParams
	results *StorageMockAddBannerToSlotResults
	Counter uint64
}

// StorageMockAddBannerToSlotParams contains parameters of the Storage.AddBannerToSlot
type StorageMockAddBannerToSlotParams struct {
	ctx      context.Context
	bannerID uint64
	slotID   uint64
}

// StorageMockAddBannerToSlotResults contains results of the Storage.AddBannerToSlot
type StorageMockAddBannerToSlotResults struct {
	err error
}

// Expect sets up expected params for Storage.AddBannerToSlot
func (mmAddBannerToSlot *mStorageMockAddBannerToSlot) Expect(ctx context.Context, bannerID uint64, slotID uint64) *mStorageMockAddBannerToSlot {
	if mmAddBannerToSlot.mock.funcAddBannerToSlot != nil {
		mmAddBannerToSlot.mock.t.Fatalf("StorageMock.AddBannerToSlot mock is already set by Set")
	}

	if mmAddBannerToSlot.defaultExpectation == nil {
		mmAddBannerToSlot.defaultExpectation = &StorageMockAddBannerToSlotExpectation{}
	}

	mmAddBannerToSlot.defaultExpectation.params = &StorageMockAddBannerToSlotParams{ctx, bannerID, slotID}
	for _, e := range mmAddBannerToSlot.expectations {
		if minimock.Equal(e.params, mmAddBannerToSlot.defaultExpectation.params) {
			mmAddBannerToSlot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddBannerToSlot.defaultExpectation.params)
		}
	}

	return mmAddBannerToSlot
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddBannerToSlot
func (mmAddBannerToSlot *mStorageMockAddBannerToSlot) Inspect(f func(ctx context.Context, bannerID uint64, slotID uint64)) *mStorageMockAddBannerToSlot {
	if mmAddBannerToSlot.mock.inspectFuncAddBannerToSlot != nil {
		mmAddBannerToSlot.mock.t.Fatalf("Inspect function is already set for StorageMock.AddBannerToSlot")
	}

	mmAddBannerToSlot.mock.inspectFuncAddBannerToSlot = f

	return mmAddBannerToSlot
}

// Return sets up results that will be returned by Storage.AddBannerToSlot
func (mmAddBannerToSlot *mStorageMockAddBannerToSlot) Return(err error) *StorageMock {
	if mmAddBannerToSlot.mock.funcAddBannerToSlot != nil {
		mmAddBannerToSlot.mock.t.Fatalf("StorageMock.AddBannerToSlot mock is already set by Set")
	}

	if mmAddBannerToSlot.defaultExpectation == nil {
		mmAddBannerToSlot.defaultExpectation = &StorageMockAddBannerToSlotExpectation{mock: mmAddBannerToSlot.mock}
	}
	mmAddBannerToSlot.defaultExpectation.results = &StorageMockAddBannerToSlotResults{err}
	return mmAddBannerToSlot.mock
}

//Set uses given function f to mock the Storage.AddBannerToSlot method
func (mmAddBannerToSlot *mStorageMockAddBannerToSlot) Set(f func(ctx context.Context, bannerID uint64, slotID uint64) (err error)) *StorageMock {
	if mmAddBannerToSlot.defaultExpectation != nil {
		mmAddBannerToSlot.mock.t.Fatalf("Default expectation is already set for the Storage.AddBannerToSlot method")
	}

	if len(mmAddBannerToSlot.expectations) > 0 {
		mmAddBannerToSlot.mock.t.Fatalf("Some expectations are already set for the Storage.AddBannerToSlot method")
	}

	mmAddBannerToSlot.mock.funcAddBannerToSlot = f
	return mmAddBannerToSlot.mock
}

// When sets expectation for the Storage.AddBannerToSlot which will trigger the result defined by the following
// Then helper
func (mmAddBannerToSlot *mStorageMockAddBannerToSlot) When(ctx context.Context, bannerID uint64, slotID uint64) *StorageMockAddBannerToSlotExpectation {
	if mmAddBannerToSlot.mock.funcAddBannerToSlot != nil {
		mmAddBannerToSlot.mock.t.Fatalf("StorageMock.AddBannerToSlot mock is already set by Set")
	}

	expectation := &StorageMockAddBannerToSlotExpectation{
		mock:   mmAddBannerToSlot.mock,
		params: &StorageMockAddBannerToSlotParams{ctx, bannerID, slotID},
	}
	mmAddBannerToSlot.expectations = append(mmAddBannerToSlot.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddBannerToSlot return parameters for the expectation previously defined by the When method
func (e *StorageMockAddBannerToSlotExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockAddBannerToSlotResults{err}
	return e.mock
}

// AddBannerToSlot implements Storage
func (mmAddBannerToSlot *StorageMock) AddBannerToSlot(ctx context.Context, bannerID uint64, slotID uint64) (err error) {
	mm_atomic.AddUint64(&mmAddBannerToSlot.beforeAddBannerToSlotCounter, 1)
	defer mm_atomic.AddUint64(&mmAddBannerToSlot.afterAddBannerToSlotCounter, 1)

	if mmAddBannerToSlot.inspectFuncAddBannerToSlot != nil {
		mmAddBannerToSlot.inspectFuncAddBannerToSlot(ctx, bannerID, slotID)
	}

	mm_params := &StorageMockAddBannerToSlotParams{ctx, bannerID, slotID}

	// Record call args
	mmAddBannerToSlot.AddBannerToSlotMock.mutex.Lock()
	mmAddBannerToSlot.AddBannerToSlotMock.callArgs = append(mmAddBannerToSlot.AddBannerToSlotMock.callArgs, mm_params)
	mmAddBannerToSlot.AddBannerToSlotMock.mutex.Unlock()

	for _, e := range mmAddBannerToSlot.AddBannerToSlotMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddBannerToSlot.AddBannerToSlotMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddBannerToSlot.AddBannerToSlotMock.defaultExpectation.Counter, 1)
		mm_want := mmAddBannerToSlot.AddBannerToSlotMock.defaultExpectation.params
		mm_got := StorageMockAddBannerToSlotParams{ctx, bannerID, slotID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddBannerToSlot.t.Errorf("StorageMock.AddBannerToSlot got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddBannerToSlot.AddBannerToSlotMock.defaultExpectation.results
		if mm_results == nil {
			mmAddBannerToSlot.t.Fatal("No results are set for the StorageMock.AddBannerToSlot")
		}
		return (*mm_results).err
	}
	if mmAddBannerToSlot.funcAddBannerToSlot != nil {
		return mmAddBannerToSlot.funcAddBannerToSlot(ctx, bannerID, slotID)
	}
	mmAddBannerToSlot.t.Fatalf("Unexpected call to StorageMock.AddBannerToSlot. %v %v %v", ctx, bannerID, slotID)
	return
}

// AddBannerToSlotAfterCounter returns a count of finished StorageMock.AddBannerToSlot invocations
func (mmAddBannerToSlot *StorageMock) AddBannerToSlotAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBannerToSlot.afterAddBannerToSlotCounter)
}

// AddBannerToSlotBeforeCounter returns a count of StorageMock.AddBannerToSlot invocations
func (mmAddBannerToSlot *StorageMock) AddBannerToSlotBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBannerToSlot.beforeAddBannerToSlotCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AddBannerToSlot.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddBannerToSlot *mStorageMockAddBannerToSlot) Calls() []*StorageMockAddBannerToSlotParams {
	mmAddBannerToSlot.mutex.RLock()

	argCopy := make([]*StorageMockAddBannerToSlotParams, len(mmAddBannerToSlot.callArgs))
	copy(argCopy, mmAddBannerToSlot.callArgs)

	mmAddBannerToSlot.mutex.RUnlock()

	return argCopy
}

// MinimockAddBannerToSlotDone returns true if the count of the AddBannerToSlot invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddBannerToSlotDone() bool {
	for _, e := range m.AddBannerToSlotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddBannerToSlotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddBannerToSlotCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBannerToSlot != nil && mm_atomic.LoadUint64(&m.afterAddBannerToSlotCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddBannerToSlotInspect logs each unmet expectation
func (m *StorageMock) MinimockAddBannerToSlotInspect() {
	for _, e := range m.AddBannerToSlotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AddBannerToSlot with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddBannerToSlotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddBannerToSlotCounter) < 1 {
		if m.AddBannerToSlotMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.AddBannerToSlot")
		} else {
			m.t.Errorf("Expected call to StorageMock.AddBannerToSlot with params: %#v", *m.AddBannerToSlotMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBannerToSlot != nil && mm_atomic.LoadUint64(&m.afterAddBannerToSlotCounter) < 1 {
		m.t.Error("Expected call to StorageMock.AddBannerToSlot")
	}
}

type mStorageMockAddClickForBanner struct {
	mock               *StorageMock
	defaultExpectation *StorageMockAddClickForBannerExpectation
	expectations       []*StorageMockAddClickForBannerExpectation

	callArgs []*StorageMockAddClickForBannerParams
	mutex    sync.RWMutex
}

// StorageMockAddClickForBannerExpectation specifies expectation struct of the Storage.AddClickForBanner
type StorageMockAddClickForBannerExpectation struct {
	mock    *StorageMock
	params  *StorageMockAddClickForBannerParams
	results *StorageMockAddClickForBannerResults
	Counter uint64
}

// StorageMockAddClickForBannerParams contains parameters of the Storage.AddClickForBanner
type StorageMockAddClickForBannerParams struct {
	ctx         context.Context
	bannerID    uint64
	slotID      uint64
	userGroupID uint64
}

// StorageMockAddClickForBannerResults contains results of the Storage.AddClickForBanner
type StorageMockAddClickForBannerResults struct {
	err error
}

// Expect sets up expected params for Storage.AddClickForBanner
func (mmAddClickForBanner *mStorageMockAddClickForBanner) Expect(ctx context.Context, bannerID uint64, slotID uint64, userGroupID uint64) *mStorageMockAddClickForBanner {
	if mmAddClickForBanner.mock.funcAddClickForBanner != nil {
		mmAddClickForBanner.mock.t.Fatalf("StorageMock.AddClickForBanner mock is already set by Set")
	}

	if mmAddClickForBanner.defaultExpectation == nil {
		mmAddClickForBanner.defaultExpectation = &StorageMockAddClickForBannerExpectation{}
	}

	mmAddClickForBanner.defaultExpectation.params = &StorageMockAddClickForBannerParams{ctx, bannerID, slotID, userGroupID}
	for _, e := range mmAddClickForBanner.expectations {
		if minimock.Equal(e.params, mmAddClickForBanner.defaultExpectation.params) {
			mmAddClickForBanner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddClickForBanner.defaultExpectation.params)
		}
	}

	return mmAddClickForBanner
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddClickForBanner
func (mmAddClickForBanner *mStorageMockAddClickForBanner) Inspect(f func(ctx context.Context, bannerID uint64, slotID uint64, userGroupID uint64)) *mStorageMockAddClickForBanner {
	if mmAddClickForBanner.mock.inspectFuncAddClickForBanner != nil {
		mmAddClickForBanner.mock.t.Fatalf("Inspect function is already set for StorageMock.AddClickForBanner")
	}

	mmAddClickForBanner.mock.inspectFuncAddClickForBanner = f

	return mmAddClickForBanner
}

// Return sets up results that will be returned by Storage.AddClickForBanner
func (mmAddClickForBanner *mStorageMockAddClickForBanner) Return(err error) *StorageMock {
	if mmAddClickForBanner.mock.funcAddClickForBanner != nil {
		mmAddClickForBanner.mock.t.Fatalf("StorageMock.AddClickForBanner mock is already set by Set")
	}

	if mmAddClickForBanner.defaultExpectation == nil {
		mmAddClickForBanner.defaultExpectation = &StorageMockAddClickForBannerExpectation{mock: mmAddClickForBanner.mock}
	}
	mmAddClickForBanner.defaultExpectation.results = &StorageMockAddClickForBannerResults{err}
	return mmAddClickForBanner.mock
}

//Set uses given function f to mock the Storage.AddClickForBanner method
func (mmAddClickForBanner *mStorageMockAddClickForBanner) Set(f func(ctx context.Context, bannerID uint64, slotID uint64, userGroupID uint64) (err error)) *StorageMock {
	if mmAddClickForBanner.defaultExpectation != nil {
		mmAddClickForBanner.mock.t.Fatalf("Default expectation is already set for the Storage.AddClickForBanner method")
	}

	if len(mmAddClickForBanner.expectations) > 0 {
		mmAddClickForBanner.mock.t.Fatalf("Some expectations are already set for the Storage.AddClickForBanner method")
	}

	mmAddClickForBanner.mock.funcAddClickForBanner = f
	return mmAddClickForBanner.mock
}

// When sets expectation for the Storage.AddClickForBanner which will trigger the result defined by the following
// Then helper
func (mmAddClickForBanner *mStorageMockAddClickForBanner) When(ctx context.Context, bannerID uint64, slotID uint64, userGroupID uint64) *StorageMockAddClickForBannerExpectation {
	if mmAddClickForBanner.mock.funcAddClickForBanner != nil {
		mmAddClickForBanner.mock.t.Fatalf("StorageMock.AddClickForBanner mock is already set by Set")
	}

	expectation := &StorageMockAddClickForBannerExpectation{
		mock:   mmAddClickForBanner.mock,
		params: &StorageMockAddClickForBannerParams{ctx, bannerID, slotID, userGroupID},
	}
	mmAddClickForBanner.expectations = append(mmAddClickForBanner.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddClickForBanner return parameters for the expectation previously defined by the When method
func (e *StorageMockAddClickForBannerExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockAddClickForBannerResults{err}
	return e.mock
}

// AddClickForBanner implements Storage
func (mmAddClickForBanner *StorageMock) AddClickForBanner(ctx context.Context, bannerID uint64, slotID uint64, userGroupID uint64) (err error) {
	mm_atomic.AddUint64(&mmAddClickForBanner.beforeAddClickForBannerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddClickForBanner.afterAddClickForBannerCounter, 1)

	if mmAddClickForBanner.inspectFuncAddClickForBanner != nil {
		mmAddClickForBanner.inspectFuncAddClickForBanner(ctx, bannerID, slotID, userGroupID)
	}

	mm_params := &StorageMockAddClickForBannerParams{ctx, bannerID, slotID, userGroupID}

	// Record call args
	mmAddClickForBanner.AddClickForBannerMock.mutex.Lock()
	mmAddClickForBanner.AddClickForBannerMock.callArgs = append(mmAddClickForBanner.AddClickForBannerMock.callArgs, mm_params)
	mmAddClickForBanner.AddClickForBannerMock.mutex.Unlock()

	for _, e := range mmAddClickForBanner.AddClickForBannerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddClickForBanner.AddClickForBannerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddClickForBanner.AddClickForBannerMock.defaultExpectation.Counter, 1)
		mm_want := mmAddClickForBanner.AddClickForBannerMock.defaultExpectation.params
		mm_got := StorageMockAddClickForBannerParams{ctx, bannerID, slotID, userGroupID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddClickForBanner.t.Errorf("StorageMock.AddClickForBanner got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddClickForBanner.AddClickForBannerMock.defaultExpectation.results
		if mm_results == nil {
			mmAddClickForBanner.t.Fatal("No results are set for the StorageMock.AddClickForBanner")
		}
		return (*mm_results).err
	}
	if mmAddClickForBanner.funcAddClickForBanner != nil {
		return mmAddClickForBanner.funcAddClickForBanner(ctx, bannerID, slotID, userGroupID)
	}
	mmAddClickForBanner.t.Fatalf("Unexpected call to StorageMock.AddClickForBanner. %v %v %v %v", ctx, bannerID, slotID, userGroupID)
	return
}

// AddClickForBannerAfterCounter returns a count of finished StorageMock.AddClickForBanner invocations
func (mmAddClickForBanner *StorageMock) AddClickForBannerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddClickForBanner.afterAddClickForBannerCounter)
}

// AddClickForBannerBeforeCounter returns a count of StorageMock.AddClickForBanner invocations
func (mmAddClickForBanner *StorageMock) AddClickForBannerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddClickForBanner.beforeAddClickForBannerCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AddClickForBanner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddClickForBanner *mStorageMockAddClickForBanner) Calls() []*StorageMockAddClickForBannerParams {
	mmAddClickForBanner.mutex.RLock()

	argCopy := make([]*StorageMockAddClickForBannerParams, len(mmAddClickForBanner.callArgs))
	copy(argCopy, mmAddClickForBanner.callArgs)

	mmAddClickForBanner.mutex.RUnlock()

	return argCopy
}

// MinimockAddClickForBannerDone returns true if the count of the AddClickForBanner invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddClickForBannerDone() bool {
	for _, e := range m.AddClickForBannerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddClickForBannerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddClickForBannerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddClickForBanner != nil && mm_atomic.LoadUint64(&m.afterAddClickForBannerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddClickForBannerInspect logs each unmet expectation
func (m *StorageMock) MinimockAddClickForBannerInspect() {
	for _, e := range m.AddClickForBannerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AddClickForBanner with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddClickForBannerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddClickForBannerCounter) < 1 {
		if m.AddClickForBannerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.AddClickForBanner")
		} else {
			m.t.Errorf("Expected call to StorageMock.AddClickForBanner with params: %#v", *m.AddClickForBannerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddClickForBanner != nil && mm_atomic.LoadUint64(&m.afterAddClickForBannerCounter) < 1 {
		m.t.Error("Expected call to StorageMock.AddClickForBanner")
	}
}

type mStorageMockBannersClickStatisticsFilterByDate struct {
	mock               *StorageMock
	defaultExpectation *StorageMockBannersClickStatisticsFilterByDateExpectation
	expectations       []*StorageMockBannersClickStatisticsFilterByDateExpectation

	callArgs []*StorageMockBannersClickStatisticsFilterByDateParams
	mutex    sync.RWMutex
}

// StorageMockBannersClickStatisticsFilterByDateExpectation specifies expectation struct of the Storage.BannersClickStatisticsFilterByDate
type StorageMockBannersClickStatisticsFilterByDateExpectation struct {
	mock    *StorageMock
	params  *StorageMockBannersClickStatisticsFilterByDateParams
	results *StorageMockBannersClickStatisticsFilterByDateResults
	Counter uint64
}

// StorageMockBannersClickStatisticsFilterByDateParams contains parameters of the Storage.BannersClickStatisticsFilterByDate
type StorageMockBannersClickStatisticsFilterByDateParams struct {
	ctx  context.Context
	from int64
	to   int64
}

// StorageMockBannersClickStatisticsFilterByDateResults contains results of the Storage.BannersClickStatisticsFilterByDate
type StorageMockBannersClickStatisticsFilterByDateResults struct {
	ba1 []BannerStatistic
	err error
}

// Expect sets up expected params for Storage.BannersClickStatisticsFilterByDate
func (mmBannersClickStatisticsFilterByDate *mStorageMockBannersClickStatisticsFilterByDate) Expect(ctx context.Context, from int64, to int64) *mStorageMockBannersClickStatisticsFilterByDate {
	if mmBannersClickStatisticsFilterByDate.mock.funcBannersClickStatisticsFilterByDate != nil {
		mmBannersClickStatisticsFilterByDate.mock.t.Fatalf("StorageMock.BannersClickStatisticsFilterByDate mock is already set by Set")
	}

	if mmBannersClickStatisticsFilterByDate.defaultExpectation == nil {
		mmBannersClickStatisticsFilterByDate.defaultExpectation = &StorageMockBannersClickStatisticsFilterByDateExpectation{}
	}

	mmBannersClickStatisticsFilterByDate.defaultExpectation.params = &StorageMockBannersClickStatisticsFilterByDateParams{ctx, from, to}
	for _, e := range mmBannersClickStatisticsFilterByDate.expectations {
		if minimock.Equal(e.params, mmBannersClickStatisticsFilterByDate.defaultExpectation.params) {
			mmBannersClickStatisticsFilterByDate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBannersClickStatisticsFilterByDate.defaultExpectation.params)
		}
	}

	return mmBannersClickStatisticsFilterByDate
}

// Inspect accepts an inspector function that has same arguments as the Storage.BannersClickStatisticsFilterByDate
func (mmBannersClickStatisticsFilterByDate *mStorageMockBannersClickStatisticsFilterByDate) Inspect(f func(ctx context.Context, from int64, to int64)) *mStorageMockBannersClickStatisticsFilterByDate {
	if mmBannersClickStatisticsFilterByDate.mock.inspectFuncBannersClickStatisticsFilterByDate != nil {
		mmBannersClickStatisticsFilterByDate.mock.t.Fatalf("Inspect function is already set for StorageMock.BannersClickStatisticsFilterByDate")
	}

	mmBannersClickStatisticsFilterByDate.mock.inspectFuncBannersClickStatisticsFilterByDate = f

	return mmBannersClickStatisticsFilterByDate
}

// Return sets up results that will be returned by Storage.BannersClickStatisticsFilterByDate
func (mmBannersClickStatisticsFilterByDate *mStorageMockBannersClickStatisticsFilterByDate) Return(ba1 []BannerStatistic, err error) *StorageMock {
	if mmBannersClickStatisticsFilterByDate.mock.funcBannersClickStatisticsFilterByDate != nil {
		mmBannersClickStatisticsFilterByDate.mock.t.Fatalf("StorageMock.BannersClickStatisticsFilterByDate mock is already set by Set")
	}

	if mmBannersClickStatisticsFilterByDate.defaultExpectation == nil {
		mmBannersClickStatisticsFilterByDate.defaultExpectation = &StorageMockBannersClickStatisticsFilterByDateExpectation{mock: mmBannersClickStatisticsFilterByDate.mock}
	}
	mmBannersClickStatisticsFilterByDate.defaultExpectation.results = &StorageMockBannersClickStatisticsFilterByDateResults{ba1, err}
	return mmBannersClickStatisticsFilterByDate.mock
}

//Set uses given function f to mock the Storage.BannersClickStatisticsFilterByDate method
func (mmBannersClickStatisticsFilterByDate *mStorageMockBannersClickStatisticsFilterByDate) Set(f func(ctx context.Context, from int64, to int64) (ba1 []BannerStatistic, err error)) *StorageMock {
	if mmBannersClickStatisticsFilterByDate.defaultExpectation != nil {
		mmBannersClickStatisticsFilterByDate.mock.t.Fatalf("Default expectation is already set for the Storage.BannersClickStatisticsFilterByDate method")
	}

	if len(mmBannersClickStatisticsFilterByDate.expectations) > 0 {
		mmBannersClickStatisticsFilterByDate.mock.t.Fatalf("Some expectations are already set for the Storage.BannersClickStatisticsFilterByDate method")
	}

	mmBannersClickStatisticsFilterByDate.mock.funcBannersClickStatisticsFilterByDate = f
	return mmBannersClickStatisticsFilterByDate.mock
}

// When sets expectation for the Storage.BannersClickStatisticsFilterByDate which will trigger the result defined by the following
// Then helper
func (mmBannersClickStatisticsFilterByDate *mStorageMockBannersClickStatisticsFilterByDate) When(ctx context.Context, from int64, to int64) *StorageMockBannersClickStatisticsFilterByDateExpectation {
	if mmBannersClickStatisticsFilterByDate.mock.funcBannersClickStatisticsFilterByDate != nil {
		mmBannersClickStatisticsFilterByDate.mock.t.Fatalf("StorageMock.BannersClickStatisticsFilterByDate mock is already set by Set")
	}

	expectation := &StorageMockBannersClickStatisticsFilterByDateExpectation{
		mock:   mmBannersClickStatisticsFilterByDate.mock,
		params: &StorageMockBannersClickStatisticsFilterByDateParams{ctx, from, to},
	}
	mmBannersClickStatisticsFilterByDate.expectations = append(mmBannersClickStatisticsFilterByDate.expectations, expectation)
	return expectation
}

// Then sets up Storage.BannersClickStatisticsFilterByDate return parameters for the expectation previously defined by the When method
func (e *StorageMockBannersClickStatisticsFilterByDateExpectation) Then(ba1 []BannerStatistic, err error) *StorageMock {
	e.results = &StorageMockBannersClickStatisticsFilterByDateResults{ba1, err}
	return e.mock
}

// BannersClickStatisticsFilterByDate implements Storage
func (mmBannersClickStatisticsFilterByDate *StorageMock) BannersClickStatisticsFilterByDate(ctx context.Context, from int64, to int64) (ba1 []BannerStatistic, err error) {
	mm_atomic.AddUint64(&mmBannersClickStatisticsFilterByDate.beforeBannersClickStatisticsFilterByDateCounter, 1)
	defer mm_atomic.AddUint64(&mmBannersClickStatisticsFilterByDate.afterBannersClickStatisticsFilterByDateCounter, 1)

	if mmBannersClickStatisticsFilterByDate.inspectFuncBannersClickStatisticsFilterByDate != nil {
		mmBannersClickStatisticsFilterByDate.inspectFuncBannersClickStatisticsFilterByDate(ctx, from, to)
	}

	mm_params := &StorageMockBannersClickStatisticsFilterByDateParams{ctx, from, to}

	// Record call args
	mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.mutex.Lock()
	mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.callArgs = append(mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.callArgs, mm_params)
	mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.mutex.Unlock()

	for _, e := range mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.defaultExpectation.Counter, 1)
		mm_want := mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.defaultExpectation.params
		mm_got := StorageMockBannersClickStatisticsFilterByDateParams{ctx, from, to}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBannersClickStatisticsFilterByDate.t.Errorf("StorageMock.BannersClickStatisticsFilterByDate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBannersClickStatisticsFilterByDate.BannersClickStatisticsFilterByDateMock.defaultExpectation.results
		if mm_results == nil {
			mmBannersClickStatisticsFilterByDate.t.Fatal("No results are set for the StorageMock.BannersClickStatisticsFilterByDate")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmBannersClickStatisticsFilterByDate.funcBannersClickStatisticsFilterByDate != nil {
		return mmBannersClickStatisticsFilterByDate.funcBannersClickStatisticsFilterByDate(ctx, from, to)
	}
	mmBannersClickStatisticsFilterByDate.t.Fatalf("Unexpected call to StorageMock.BannersClickStatisticsFilterByDate. %v %v %v", ctx, from, to)
	return
}

// BannersClickStatisticsFilterByDateAfterCounter returns a count of finished StorageMock.BannersClickStatisticsFilterByDate invocations
func (mmBannersClickStatisticsFilterByDate *StorageMock) BannersClickStatisticsFilterByDateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBannersClickStatisticsFilterByDate.afterBannersClickStatisticsFilterByDateCounter)
}

// BannersClickStatisticsFilterByDateBeforeCounter returns a count of StorageMock.BannersClickStatisticsFilterByDate invocations
func (mmBannersClickStatisticsFilterByDate *StorageMock) BannersClickStatisticsFilterByDateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBannersClickStatisticsFilterByDate.beforeBannersClickStatisticsFilterByDateCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.BannersClickStatisticsFilterByDate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBannersClickStatisticsFilterByDate *mStorageMockBannersClickStatisticsFilterByDate) Calls() []*StorageMockBannersClickStatisticsFilterByDateParams {
	mmBannersClickStatisticsFilterByDate.mutex.RLock()

	argCopy := make([]*StorageMockBannersClickStatisticsFilterByDateParams, len(mmBannersClickStatisticsFilterByDate.callArgs))
	copy(argCopy, mmBannersClickStatisticsFilterByDate.callArgs)

	mmBannersClickStatisticsFilterByDate.mutex.RUnlock()

	return argCopy
}

// MinimockBannersClickStatisticsFilterByDateDone returns true if the count of the BannersClickStatisticsFilterByDate invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockBannersClickStatisticsFilterByDateDone() bool {
	for _, e := range m.BannersClickStatisticsFilterByDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BannersClickStatisticsFilterByDateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBannersClickStatisticsFilterByDateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBannersClickStatisticsFilterByDate != nil && mm_atomic.LoadUint64(&m.afterBannersClickStatisticsFilterByDateCounter) < 1 {
		return false
	}
	return true
}

// MinimockBannersClickStatisticsFilterByDateInspect logs each unmet expectation
func (m *StorageMock) MinimockBannersClickStatisticsFilterByDateInspect() {
	for _, e := range m.BannersClickStatisticsFilterByDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.BannersClickStatisticsFilterByDate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BannersClickStatisticsFilterByDateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBannersClickStatisticsFilterByDateCounter) < 1 {
		if m.BannersClickStatisticsFilterByDateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.BannersClickStatisticsFilterByDate")
		} else {
			m.t.Errorf("Expected call to StorageMock.BannersClickStatisticsFilterByDate with params: %#v", *m.BannersClickStatisticsFilterByDateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBannersClickStatisticsFilterByDate != nil && mm_atomic.LoadUint64(&m.afterBannersClickStatisticsFilterByDateCounter) < 1 {
		m.t.Error("Expected call to StorageMock.BannersClickStatisticsFilterByDate")
	}
}

type mStorageMockBannersShowStatisticsFilterByDate struct {
	mock               *StorageMock
	defaultExpectation *StorageMockBannersShowStatisticsFilterByDateExpectation
	expectations       []*StorageMockBannersShowStatisticsFilterByDateExpectation

	callArgs []*StorageMockBannersShowStatisticsFilterByDateParams
	mutex    sync.RWMutex
}

// StorageMockBannersShowStatisticsFilterByDateExpectation specifies expectation struct of the Storage.BannersShowStatisticsFilterByDate
type StorageMockBannersShowStatisticsFilterByDateExpectation struct {
	mock    *StorageMock
	params  *StorageMockBannersShowStatisticsFilterByDateParams
	results *StorageMockBannersShowStatisticsFilterByDateResults
	Counter uint64
}

// StorageMockBannersShowStatisticsFilterByDateParams contains parameters of the Storage.BannersShowStatisticsFilterByDate
type StorageMockBannersShowStatisticsFilterByDateParams struct {
	ctx  context.Context
	from int64
	to   int64
}

// StorageMockBannersShowStatisticsFilterByDateResults contains results of the Storage.BannersShowStatisticsFilterByDate
type StorageMockBannersShowStatisticsFilterByDateResults struct {
	ba1 []BannerStatistic
	err error
}

// Expect sets up expected params for Storage.BannersShowStatisticsFilterByDate
func (mmBannersShowStatisticsFilterByDate *mStorageMockBannersShowStatisticsFilterByDate) Expect(ctx context.Context, from int64, to int64) *mStorageMockBannersShowStatisticsFilterByDate {
	if mmBannersShowStatisticsFilterByDate.mock.funcBannersShowStatisticsFilterByDate != nil {
		mmBannersShowStatisticsFilterByDate.mock.t.Fatalf("StorageMock.BannersShowStatisticsFilterByDate mock is already set by Set")
	}

	if mmBannersShowStatisticsFilterByDate.defaultExpectation == nil {
		mmBannersShowStatisticsFilterByDate.defaultExpectation = &StorageMockBannersShowStatisticsFilterByDateExpectation{}
	}

	mmBannersShowStatisticsFilterByDate.defaultExpectation.params = &StorageMockBannersShowStatisticsFilterByDateParams{ctx, from, to}
	for _, e := range mmBannersShowStatisticsFilterByDate.expectations {
		if minimock.Equal(e.params, mmBannersShowStatisticsFilterByDate.defaultExpectation.params) {
			mmBannersShowStatisticsFilterByDate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBannersShowStatisticsFilterByDate.defaultExpectation.params)
		}
	}

	return mmBannersShowStatisticsFilterByDate
}

// Inspect accepts an inspector function that has same arguments as the Storage.BannersShowStatisticsFilterByDate
func (mmBannersShowStatisticsFilterByDate *mStorageMockBannersShowStatisticsFilterByDate) Inspect(f func(ctx context.Context, from int64, to int64)) *mStorageMockBannersShowStatisticsFilterByDate {
	if mmBannersShowStatisticsFilterByDate.mock.inspectFuncBannersShowStatisticsFilterByDate != nil {
		mmBannersShowStatisticsFilterByDate.mock.t.Fatalf("Inspect function is already set for StorageMock.BannersShowStatisticsFilterByDate")
	}

	mmBannersShowStatisticsFilterByDate.mock.inspectFuncBannersShowStatisticsFilterByDate = f

	return mmBannersShowStatisticsFilterByDate
}

// Return sets up results that will be returned by Storage.BannersShowStatisticsFilterByDate
func (mmBannersShowStatisticsFilterByDate *mStorageMockBannersShowStatisticsFilterByDate) Return(ba1 []BannerStatistic, err error) *StorageMock {
	if mmBannersShowStatisticsFilterByDate.mock.funcBannersShowStatisticsFilterByDate != nil {
		mmBannersShowStatisticsFilterByDate.mock.t.Fatalf("StorageMock.BannersShowStatisticsFilterByDate mock is already set by Set")
	}

	if mmBannersShowStatisticsFilterByDate.defaultExpectation == nil {
		mmBannersShowStatisticsFilterByDate.defaultExpectation = &StorageMockBannersShowStatisticsFilterByDateExpectation{mock: mmBannersShowStatisticsFilterByDate.mock}
	}
	mmBannersShowStatisticsFilterByDate.defaultExpectation.results = &StorageMockBannersShowStatisticsFilterByDateResults{ba1, err}
	return mmBannersShowStatisticsFilterByDate.mock
}

//Set uses given function f to mock the Storage.BannersShowStatisticsFilterByDate method
func (mmBannersShowStatisticsFilterByDate *mStorageMockBannersShowStatisticsFilterByDate) Set(f func(ctx context.Context, from int64, to int64) (ba1 []BannerStatistic, err error)) *StorageMock {
	if mmBannersShowStatisticsFilterByDate.defaultExpectation != nil {
		mmBannersShowStatisticsFilterByDate.mock.t.Fatalf("Default expectation is already set for the Storage.BannersShowStatisticsFilterByDate method")
	}

	if len(mmBannersShowStatisticsFilterByDate.expectations) > 0 {
		mmBannersShowStatisticsFilterByDate.mock.t.Fatalf("Some expectations are already set for the Storage.BannersShowStatisticsFilterByDate method")
	}

	mmBannersShowStatisticsFilterByDate.mock.funcBannersShowStatisticsFilterByDate = f
	return mmBannersShowStatisticsFilterByDate.mock
}

// When sets expectation for the Storage.BannersShowStatisticsFilterByDate which will trigger the result defined by the following
// Then helper
func (mmBannersShowStatisticsFilterByDate *mStorageMockBannersShowStatisticsFilterByDate) When(ctx context.Context, from int64, to int64) *StorageMockBannersShowStatisticsFilterByDateExpectation {
	if mmBannersShowStatisticsFilterByDate.mock.funcBannersShowStatisticsFilterByDate != nil {
		mmBannersShowStatisticsFilterByDate.mock.t.Fatalf("StorageMock.BannersShowStatisticsFilterByDate mock is already set by Set")
	}

	expectation := &StorageMockBannersShowStatisticsFilterByDateExpectation{
		mock:   mmBannersShowStatisticsFilterByDate.mock,
		params: &StorageMockBannersShowStatisticsFilterByDateParams{ctx, from, to},
	}
	mmBannersShowStatisticsFilterByDate.expectations = append(mmBannersShowStatisticsFilterByDate.expectations, expectation)
	return expectation
}

// Then sets up Storage.BannersShowStatisticsFilterByDate return parameters for the expectation previously defined by the When method
func (e *StorageMockBannersShowStatisticsFilterByDateExpectation) Then(ba1 []BannerStatistic, err error) *StorageMock {
	e.results = &StorageMockBannersShowStatisticsFilterByDateResults{ba1, err}
	return e.mock
}

// BannersShowStatisticsFilterByDate implements Storage
func (mmBannersShowStatisticsFilterByDate *StorageMock) BannersShowStatisticsFilterByDate(ctx context.Context, from int64, to int64) (ba1 []BannerStatistic, err error) {
	mm_atomic.AddUint64(&mmBannersShowStatisticsFilterByDate.beforeBannersShowStatisticsFilterByDateCounter, 1)
	defer mm_atomic.AddUint64(&mmBannersShowStatisticsFilterByDate.afterBannersShowStatisticsFilterByDateCounter, 1)

	if mmBannersShowStatisticsFilterByDate.inspectFuncBannersShowStatisticsFilterByDate != nil {
		mmBannersShowStatisticsFilterByDate.inspectFuncBannersShowStatisticsFilterByDate(ctx, from, to)
	}

	mm_params := &StorageMockBannersShowStatisticsFilterByDateParams{ctx, from, to}

	// Record call args
	mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.mutex.Lock()
	mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.callArgs = append(mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.callArgs, mm_params)
	mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.mutex.Unlock()

	for _, e := range mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.defaultExpectation.Counter, 1)
		mm_want := mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.defaultExpectation.params
		mm_got := StorageMockBannersShowStatisticsFilterByDateParams{ctx, from, to}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBannersShowStatisticsFilterByDate.t.Errorf("StorageMock.BannersShowStatisticsFilterByDate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBannersShowStatisticsFilterByDate.BannersShowStatisticsFilterByDateMock.defaultExpectation.results
		if mm_results == nil {
			mmBannersShowStatisticsFilterByDate.t.Fatal("No results are set for the StorageMock.BannersShowStatisticsFilterByDate")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmBannersShowStatisticsFilterByDate.funcBannersShowStatisticsFilterByDate != nil {
		return mmBannersShowStatisticsFilterByDate.funcBannersShowStatisticsFilterByDate(ctx, from, to)
	}
	mmBannersShowStatisticsFilterByDate.t.Fatalf("Unexpected call to StorageMock.BannersShowStatisticsFilterByDate. %v %v %v", ctx, from, to)
	return
}

// BannersShowStatisticsFilterByDateAfterCounter returns a count of finished StorageMock.BannersShowStatisticsFilterByDate invocations
func (mmBannersShowStatisticsFilterByDate *StorageMock) BannersShowStatisticsFilterByDateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBannersShowStatisticsFilterByDate.afterBannersShowStatisticsFilterByDateCounter)
}

// BannersShowStatisticsFilterByDateBeforeCounter returns a count of StorageMock.BannersShowStatisticsFilterByDate invocations
func (mmBannersShowStatisticsFilterByDate *StorageMock) BannersShowStatisticsFilterByDateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBannersShowStatisticsFilterByDate.beforeBannersShowStatisticsFilterByDateCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.BannersShowStatisticsFilterByDate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBannersShowStatisticsFilterByDate *mStorageMockBannersShowStatisticsFilterByDate) Calls() []*StorageMockBannersShowStatisticsFilterByDateParams {
	mmBannersShowStatisticsFilterByDate.mutex.RLock()

	argCopy := make([]*StorageMockBannersShowStatisticsFilterByDateParams, len(mmBannersShowStatisticsFilterByDate.callArgs))
	copy(argCopy, mmBannersShowStatisticsFilterByDate.callArgs)

	mmBannersShowStatisticsFilterByDate.mutex.RUnlock()

	return argCopy
}

// MinimockBannersShowStatisticsFilterByDateDone returns true if the count of the BannersShowStatisticsFilterByDate invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockBannersShowStatisticsFilterByDateDone() bool {
	for _, e := range m.BannersShowStatisticsFilterByDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BannersShowStatisticsFilterByDateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBannersShowStatisticsFilterByDateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBannersShowStatisticsFilterByDate != nil && mm_atomic.LoadUint64(&m.afterBannersShowStatisticsFilterByDateCounter) < 1 {
		return false
	}
	return true
}

// MinimockBannersShowStatisticsFilterByDateInspect logs each unmet expectation
func (m *StorageMock) MinimockBannersShowStatisticsFilterByDateInspect() {
	for _, e := range m.BannersShowStatisticsFilterByDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.BannersShowStatisticsFilterByDate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BannersShowStatisticsFilterByDateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBannersShowStatisticsFilterByDateCounter) < 1 {
		if m.BannersShowStatisticsFilterByDateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.BannersShowStatisticsFilterByDate")
		} else {
			m.t.Errorf("Expected call to StorageMock.BannersShowStatisticsFilterByDate with params: %#v", *m.BannersShowStatisticsFilterByDateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBannersShowStatisticsFilterByDate != nil && mm_atomic.LoadUint64(&m.afterBannersShowStatisticsFilterByDateCounter) < 1 {
		m.t.Error("Expected call to StorageMock.BannersShowStatisticsFilterByDate")
	}
}

type mStorageMockGetBannerForSlot struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetBannerForSlotExpectation
	expectations       []*StorageMockGetBannerForSlotExpectation

	callArgs []*StorageMockGetBannerForSlotParams
	mutex    sync.RWMutex
}

// StorageMockGetBannerForSlotExpectation specifies expectation struct of the Storage.GetBannerForSlot
type StorageMockGetBannerForSlotExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetBannerForSlotParams
	results *StorageMockGetBannerForSlotResults
	Counter uint64
}

// StorageMockGetBannerForSlotParams contains parameters of the Storage.GetBannerForSlot
type StorageMockGetBannerForSlotParams struct {
	ctx         context.Context
	slotID      uint64
	userGroupID uint64
}

// StorageMockGetBannerForSlotResults contains results of the Storage.GetBannerForSlot
type StorageMockGetBannerForSlotResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Storage.GetBannerForSlot
func (mmGetBannerForSlot *mStorageMockGetBannerForSlot) Expect(ctx context.Context, slotID uint64, userGroupID uint64) *mStorageMockGetBannerForSlot {
	if mmGetBannerForSlot.mock.funcGetBannerForSlot != nil {
		mmGetBannerForSlot.mock.t.Fatalf("StorageMock.GetBannerForSlot mock is already set by Set")
	}

	if mmGetBannerForSlot.defaultExpectation == nil {
		mmGetBannerForSlot.defaultExpectation = &StorageMockGetBannerForSlotExpectation{}
	}

	mmGetBannerForSlot.defaultExpectation.params = &StorageMockGetBannerForSlotParams{ctx, slotID, userGroupID}
	for _, e := range mmGetBannerForSlot.expectations {
		if minimock.Equal(e.params, mmGetBannerForSlot.defaultExpectation.params) {
			mmGetBannerForSlot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBannerForSlot.defaultExpectation.params)
		}
	}

	return mmGetBannerForSlot
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetBannerForSlot
func (mmGetBannerForSlot *mStorageMockGetBannerForSlot) Inspect(f func(ctx context.Context, slotID uint64, userGroupID uint64)) *mStorageMockGetBannerForSlot {
	if mmGetBannerForSlot.mock.inspectFuncGetBannerForSlot != nil {
		mmGetBannerForSlot.mock.t.Fatalf("Inspect function is already set for StorageMock.GetBannerForSlot")
	}

	mmGetBannerForSlot.mock.inspectFuncGetBannerForSlot = f

	return mmGetBannerForSlot
}

// Return sets up results that will be returned by Storage.GetBannerForSlot
func (mmGetBannerForSlot *mStorageMockGetBannerForSlot) Return(u1 uint64, err error) *StorageMock {
	if mmGetBannerForSlot.mock.funcGetBannerForSlot != nil {
		mmGetBannerForSlot.mock.t.Fatalf("StorageMock.GetBannerForSlot mock is already set by Set")
	}

	if mmGetBannerForSlot.defaultExpectation == nil {
		mmGetBannerForSlot.defaultExpectation = &StorageMockGetBannerForSlotExpectation{mock: mmGetBannerForSlot.mock}
	}
	mmGetBannerForSlot.defaultExpectation.results = &StorageMockGetBannerForSlotResults{u1, err}
	return mmGetBannerForSlot.mock
}

//Set uses given function f to mock the Storage.GetBannerForSlot method
func (mmGetBannerForSlot *mStorageMockGetBannerForSlot) Set(f func(ctx context.Context, slotID uint64, userGroupID uint64) (u1 uint64, err error)) *StorageMock {
	if mmGetBannerForSlot.defaultExpectation != nil {
		mmGetBannerForSlot.mock.t.Fatalf("Default expectation is already set for the Storage.GetBannerForSlot method")
	}

	if len(mmGetBannerForSlot.expectations) > 0 {
		mmGetBannerForSlot.mock.t.Fatalf("Some expectations are already set for the Storage.GetBannerForSlot method")
	}

	mmGetBannerForSlot.mock.funcGetBannerForSlot = f
	return mmGetBannerForSlot.mock
}

// When sets expectation for the Storage.GetBannerForSlot which will trigger the result defined by the following
// Then helper
func (mmGetBannerForSlot *mStorageMockGetBannerForSlot) When(ctx context.Context, slotID uint64, userGroupID uint64) *StorageMockGetBannerForSlotExpectation {
	if mmGetBannerForSlot.mock.funcGetBannerForSlot != nil {
		mmGetBannerForSlot.mock.t.Fatalf("StorageMock.GetBannerForSlot mock is already set by Set")
	}

	expectation := &StorageMockGetBannerForSlotExpectation{
		mock:   mmGetBannerForSlot.mock,
		params: &StorageMockGetBannerForSlotParams{ctx, slotID, userGroupID},
	}
	mmGetBannerForSlot.expectations = append(mmGetBannerForSlot.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetBannerForSlot return parameters for the expectation previously defined by the When method
func (e *StorageMockGetBannerForSlotExpectation) Then(u1 uint64, err error) *StorageMock {
	e.results = &StorageMockGetBannerForSlotResults{u1, err}
	return e.mock
}

// GetBannerForSlot implements Storage
func (mmGetBannerForSlot *StorageMock) GetBannerForSlot(ctx context.Context, slotID uint64, userGroupID uint64) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetBannerForSlot.beforeGetBannerForSlotCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBannerForSlot.afterGetBannerForSlotCounter, 1)

	if mmGetBannerForSlot.inspectFuncGetBannerForSlot != nil {
		mmGetBannerForSlot.inspectFuncGetBannerForSlot(ctx, slotID, userGroupID)
	}

	mm_params := &StorageMockGetBannerForSlotParams{ctx, slotID, userGroupID}

	// Record call args
	mmGetBannerForSlot.GetBannerForSlotMock.mutex.Lock()
	mmGetBannerForSlot.GetBannerForSlotMock.callArgs = append(mmGetBannerForSlot.GetBannerForSlotMock.callArgs, mm_params)
	mmGetBannerForSlot.GetBannerForSlotMock.mutex.Unlock()

	for _, e := range mmGetBannerForSlot.GetBannerForSlotMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetBannerForSlot.GetBannerForSlotMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBannerForSlot.GetBannerForSlotMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBannerForSlot.GetBannerForSlotMock.defaultExpectation.params
		mm_got := StorageMockGetBannerForSlotParams{ctx, slotID, userGroupID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBannerForSlot.t.Errorf("StorageMock.GetBannerForSlot got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBannerForSlot.GetBannerForSlotMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBannerForSlot.t.Fatal("No results are set for the StorageMock.GetBannerForSlot")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetBannerForSlot.funcGetBannerForSlot != nil {
		return mmGetBannerForSlot.funcGetBannerForSlot(ctx, slotID, userGroupID)
	}
	mmGetBannerForSlot.t.Fatalf("Unexpected call to StorageMock.GetBannerForSlot. %v %v %v", ctx, slotID, userGroupID)
	return
}

// GetBannerForSlotAfterCounter returns a count of finished StorageMock.GetBannerForSlot invocations
func (mmGetBannerForSlot *StorageMock) GetBannerForSlotAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBannerForSlot.afterGetBannerForSlotCounter)
}

// GetBannerForSlotBeforeCounter returns a count of StorageMock.GetBannerForSlot invocations
func (mmGetBannerForSlot *StorageMock) GetBannerForSlotBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBannerForSlot.beforeGetBannerForSlotCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetBannerForSlot.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBannerForSlot *mStorageMockGetBannerForSlot) Calls() []*StorageMockGetBannerForSlotParams {
	mmGetBannerForSlot.mutex.RLock()

	argCopy := make([]*StorageMockGetBannerForSlotParams, len(mmGetBannerForSlot.callArgs))
	copy(argCopy, mmGetBannerForSlot.callArgs)

	mmGetBannerForSlot.mutex.RUnlock()

	return argCopy
}

// MinimockGetBannerForSlotDone returns true if the count of the GetBannerForSlot invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetBannerForSlotDone() bool {
	for _, e := range m.GetBannerForSlotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBannerForSlotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBannerForSlotCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBannerForSlot != nil && mm_atomic.LoadUint64(&m.afterGetBannerForSlotCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBannerForSlotInspect logs each unmet expectation
func (m *StorageMock) MinimockGetBannerForSlotInspect() {
	for _, e := range m.GetBannerForSlotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetBannerForSlot with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBannerForSlotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBannerForSlotCounter) < 1 {
		if m.GetBannerForSlotMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetBannerForSlot")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetBannerForSlot with params: %#v", *m.GetBannerForSlotMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBannerForSlot != nil && mm_atomic.LoadUint64(&m.afterGetBannerForSlotCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetBannerForSlot")
	}
}

type mStorageMockRemoveBannerFromSlot struct {
	mock               *StorageMock
	defaultExpectation *StorageMockRemoveBannerFromSlotExpectation
	expectations       []*StorageMockRemoveBannerFromSlotExpectation

	callArgs []*StorageMockRemoveBannerFromSlotParams
	mutex    sync.RWMutex
}

// StorageMockRemoveBannerFromSlotExpectation specifies expectation struct of the Storage.RemoveBannerFromSlot
type StorageMockRemoveBannerFromSlotExpectation struct {
	mock    *StorageMock
	params  *StorageMockRemoveBannerFromSlotParams
	results *StorageMockRemoveBannerFromSlotResults
	Counter uint64
}

// StorageMockRemoveBannerFromSlotParams contains parameters of the Storage.RemoveBannerFromSlot
type StorageMockRemoveBannerFromSlotParams struct {
	ctx      context.Context
	bannerID uint64
	slotID   uint64
}

// StorageMockRemoveBannerFromSlotResults contains results of the Storage.RemoveBannerFromSlot
type StorageMockRemoveBannerFromSlotResults struct {
	err error
}

// Expect sets up expected params for Storage.RemoveBannerFromSlot
func (mmRemoveBannerFromSlot *mStorageMockRemoveBannerFromSlot) Expect(ctx context.Context, bannerID uint64, slotID uint64) *mStorageMockRemoveBannerFromSlot {
	if mmRemoveBannerFromSlot.mock.funcRemoveBannerFromSlot != nil {
		mmRemoveBannerFromSlot.mock.t.Fatalf("StorageMock.RemoveBannerFromSlot mock is already set by Set")
	}

	if mmRemoveBannerFromSlot.defaultExpectation == nil {
		mmRemoveBannerFromSlot.defaultExpectation = &StorageMockRemoveBannerFromSlotExpectation{}
	}

	mmRemoveBannerFromSlot.defaultExpectation.params = &StorageMockRemoveBannerFromSlotParams{ctx, bannerID, slotID}
	for _, e := range mmRemoveBannerFromSlot.expectations {
		if minimock.Equal(e.params, mmRemoveBannerFromSlot.defaultExpectation.params) {
			mmRemoveBannerFromSlot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveBannerFromSlot.defaultExpectation.params)
		}
	}

	return mmRemoveBannerFromSlot
}

// Inspect accepts an inspector function that has same arguments as the Storage.RemoveBannerFromSlot
func (mmRemoveBannerFromSlot *mStorageMockRemoveBannerFromSlot) Inspect(f func(ctx context.Context, bannerID uint64, slotID uint64)) *mStorageMockRemoveBannerFromSlot {
	if mmRemoveBannerFromSlot.mock.inspectFuncRemoveBannerFromSlot != nil {
		mmRemoveBannerFromSlot.mock.t.Fatalf("Inspect function is already set for StorageMock.RemoveBannerFromSlot")
	}

	mmRemoveBannerFromSlot.mock.inspectFuncRemoveBannerFromSlot = f

	return mmRemoveBannerFromSlot
}

// Return sets up results that will be returned by Storage.RemoveBannerFromSlot
func (mmRemoveBannerFromSlot *mStorageMockRemoveBannerFromSlot) Return(err error) *StorageMock {
	if mmRemoveBannerFromSlot.mock.funcRemoveBannerFromSlot != nil {
		mmRemoveBannerFromSlot.mock.t.Fatalf("StorageMock.RemoveBannerFromSlot mock is already set by Set")
	}

	if mmRemoveBannerFromSlot.defaultExpectation == nil {
		mmRemoveBannerFromSlot.defaultExpectation = &StorageMockRemoveBannerFromSlotExpectation{mock: mmRemoveBannerFromSlot.mock}
	}
	mmRemoveBannerFromSlot.defaultExpectation.results = &StorageMockRemoveBannerFromSlotResults{err}
	return mmRemoveBannerFromSlot.mock
}

//Set uses given function f to mock the Storage.RemoveBannerFromSlot method
func (mmRemoveBannerFromSlot *mStorageMockRemoveBannerFromSlot) Set(f func(ctx context.Context, bannerID uint64, slotID uint64) (err error)) *StorageMock {
	if mmRemoveBannerFromSlot.defaultExpectation != nil {
		mmRemoveBannerFromSlot.mock.t.Fatalf("Default expectation is already set for the Storage.RemoveBannerFromSlot method")
	}

	if len(mmRemoveBannerFromSlot.expectations) > 0 {
		mmRemoveBannerFromSlot.mock.t.Fatalf("Some expectations are already set for the Storage.RemoveBannerFromSlot method")
	}

	mmRemoveBannerFromSlot.mock.funcRemoveBannerFromSlot = f
	return mmRemoveBannerFromSlot.mock
}

// When sets expectation for the Storage.RemoveBannerFromSlot which will trigger the result defined by the following
// Then helper
func (mmRemoveBannerFromSlot *mStorageMockRemoveBannerFromSlot) When(ctx context.Context, bannerID uint64, slotID uint64) *StorageMockRemoveBannerFromSlotExpectation {
	if mmRemoveBannerFromSlot.mock.funcRemoveBannerFromSlot != nil {
		mmRemoveBannerFromSlot.mock.t.Fatalf("StorageMock.RemoveBannerFromSlot mock is already set by Set")
	}

	expectation := &StorageMockRemoveBannerFromSlotExpectation{
		mock:   mmRemoveBannerFromSlot.mock,
		params: &StorageMockRemoveBannerFromSlotParams{ctx, bannerID, slotID},
	}
	mmRemoveBannerFromSlot.expectations = append(mmRemoveBannerFromSlot.expectations, expectation)
	return expectation
}

// Then sets up Storage.RemoveBannerFromSlot return parameters for the expectation previously defined by the When method
func (e *StorageMockRemoveBannerFromSlotExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockRemoveBannerFromSlotResults{err}
	return e.mock
}

// RemoveBannerFromSlot implements Storage
func (mmRemoveBannerFromSlot *StorageMock) RemoveBannerFromSlot(ctx context.Context, bannerID uint64, slotID uint64) (err error) {
	mm_atomic.AddUint64(&mmRemoveBannerFromSlot.beforeRemoveBannerFromSlotCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveBannerFromSlot.afterRemoveBannerFromSlotCounter, 1)

	if mmRemoveBannerFromSlot.inspectFuncRemoveBannerFromSlot != nil {
		mmRemoveBannerFromSlot.inspectFuncRemoveBannerFromSlot(ctx, bannerID, slotID)
	}

	mm_params := &StorageMockRemoveBannerFromSlotParams{ctx, bannerID, slotID}

	// Record call args
	mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.mutex.Lock()
	mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.callArgs = append(mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.callArgs, mm_params)
	mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.mutex.Unlock()

	for _, e := range mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.defaultExpectation.params
		mm_got := StorageMockRemoveBannerFromSlotParams{ctx, bannerID, slotID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveBannerFromSlot.t.Errorf("StorageMock.RemoveBannerFromSlot got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveBannerFromSlot.RemoveBannerFromSlotMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveBannerFromSlot.t.Fatal("No results are set for the StorageMock.RemoveBannerFromSlot")
		}
		return (*mm_results).err
	}
	if mmRemoveBannerFromSlot.funcRemoveBannerFromSlot != nil {
		return mmRemoveBannerFromSlot.funcRemoveBannerFromSlot(ctx, bannerID, slotID)
	}
	mmRemoveBannerFromSlot.t.Fatalf("Unexpected call to StorageMock.RemoveBannerFromSlot. %v %v %v", ctx, bannerID, slotID)
	return
}

// RemoveBannerFromSlotAfterCounter returns a count of finished StorageMock.RemoveBannerFromSlot invocations
func (mmRemoveBannerFromSlot *StorageMock) RemoveBannerFromSlotAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveBannerFromSlot.afterRemoveBannerFromSlotCounter)
}

// RemoveBannerFromSlotBeforeCounter returns a count of StorageMock.RemoveBannerFromSlot invocations
func (mmRemoveBannerFromSlot *StorageMock) RemoveBannerFromSlotBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveBannerFromSlot.beforeRemoveBannerFromSlotCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RemoveBannerFromSlot.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveBannerFromSlot *mStorageMockRemoveBannerFromSlot) Calls() []*StorageMockRemoveBannerFromSlotParams {
	mmRemoveBannerFromSlot.mutex.RLock()

	argCopy := make([]*StorageMockRemoveBannerFromSlotParams, len(mmRemoveBannerFromSlot.callArgs))
	copy(argCopy, mmRemoveBannerFromSlot.callArgs)

	mmRemoveBannerFromSlot.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveBannerFromSlotDone returns true if the count of the RemoveBannerFromSlot invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRemoveBannerFromSlotDone() bool {
	for _, e := range m.RemoveBannerFromSlotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveBannerFromSlotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveBannerFromSlotCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveBannerFromSlot != nil && mm_atomic.LoadUint64(&m.afterRemoveBannerFromSlotCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveBannerFromSlotInspect logs each unmet expectation
func (m *StorageMock) MinimockRemoveBannerFromSlotInspect() {
	for _, e := range m.RemoveBannerFromSlotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RemoveBannerFromSlot with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveBannerFromSlotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveBannerFromSlotCounter) < 1 {
		if m.RemoveBannerFromSlotMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.RemoveBannerFromSlot")
		} else {
			m.t.Errorf("Expected call to StorageMock.RemoveBannerFromSlot with params: %#v", *m.RemoveBannerFromSlotMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveBannerFromSlot != nil && mm_atomic.LoadUint64(&m.afterRemoveBannerFromSlotCounter) < 1 {
		m.t.Error("Expected call to StorageMock.RemoveBannerFromSlot")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddBannerToSlotInspect()

		m.MinimockAddClickForBannerInspect()

		m.MinimockBannersClickStatisticsFilterByDateInspect()

		m.MinimockBannersShowStatisticsFilterByDateInspect()

		m.MinimockGetBannerForSlotInspect()

		m.MinimockRemoveBannerFromSlotInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddBannerToSlotDone() &&
		m.MinimockAddClickForBannerDone() &&
		m.MinimockBannersClickStatisticsFilterByDateDone() &&
		m.MinimockBannersShowStatisticsFilterByDateDone() &&
		m.MinimockGetBannerForSlotDone() &&
		m.MinimockRemoveBannerFromSlotDone()
}
